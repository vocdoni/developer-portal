"use strict";(self.webpackChunkdemo=self.webpackChunkdemo||[]).push([[3773],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var r=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(n),h=i,m=d["".concat(s,".").concat(h)]||d[h]||u[h]||o;return n?r.createElement(m,a(a({ref:t},p),{},{components:n})):r.createElement(m,a({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,a=new Array(o);a[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,a[1]=l;for(var c=2;c<o;c++)a[c]=n[c];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},55317:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var r=n(87462),i=(n(67294),n(3905));const o={},a="CSP Blind Signatures",l={unversionedId:"protocol/anonymity/blind-signatures",id:"protocol/anonymity/blind-signatures",title:"CSP Blind Signatures",description:"The current approach by Vocdoni regarding determining the eligibility of a potential voter is to use a Census Merkle Tree. All voter public keys must be known in advance and aggregated together into a hash tree to compute a Merkle root. Then each voter needs to fetch their own Merkle proof to demonstrate their eligibility on a public ledger. The Merkle proof can be anonymized using a zk-SNARK so that the public ledger will verify the SNARK proof instead.",source:"@site/docs/protocol/anonymity/blind-signatures.md",sourceDirName:"protocol/anonymity",slug:"/protocol/anonymity/blind-signatures",permalink:"/protocol/anonymity/blind-signatures",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"Anonymous Voting",permalink:"/protocol/anonymity/"},next:{title:"On-Chain Pseudo-Anonymity",permalink:"/protocol/anonymity/on-chain"}},s={},c=[{value:"Salted CSP keys",id:"salted-csp-keys",level:2},{value:"Flow diagram",id:"flow-diagram",level:2},{value:"Known Problems",id:"known-problems",level:2},{value:"Links",id:"links",level:2}],p={toc:c};function u(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"csp-blind-signatures"},"CSP Blind Signatures"),(0,i.kt)("p",null,"The current approach by Vocdoni regarding determining the eligibility of a potential voter is to use a Census Merkle Tree. All voter public keys must be known in advance and aggregated together into a hash tree to compute a Merkle root. Then each voter needs to fetch their own Merkle proof to demonstrate their eligibility on a public ledger. The Merkle proof can be anonymized using a zk-SNARK so that the public ledger will verify the SNARK proof instead."),(0,i.kt)("p",null,"This approach is nice since the same census Merkle Tree can be reused repeatedly and by anyone (not only the owner). It adds resiliency to the process since any third party can obtain the tree (there is no private information involved; thus, it can be published into IPFS) to help the potential voters fetch their proofs. Finally, it is reproducible since anyone with the same list of keys could build the same root hash and verify the Tree generation was correctly executed."),(0,i.kt)("p",null,"However, this approach lacks flexibility since it is a static way to create a voter list (adding or deleting a public key requires rebuilding and publishing the census again). The current Vocdoni protocol implements an ",(0,i.kt)("inlineCode",{parentName:"p"},"updateCensus")," mechanism, but this is not very convenient for use cases that require constant census modifications (each update requires an Ethereum transaction)."),(0,i.kt)("p",null,"In order to support such scenarios and bring more flexibility to the Vocdoni stack, a new approach is proposed based on Credential Service Providers (CSP). A voter will need to show a proof provided by the election CSP for proving its eligibility which is made up of the CSP's signature to the voter's public key."),(0,i.kt)("p",null,"For preserving the anonymity of the voter, the CSP server will perform a blind signature. Blind signatures were first suggested by David Chaum: a cryptographic scheme that allows for signatures over disguised (blinded) messages. The blinder (voter in our scenario) can then un-blind the signature and use it as a normal/standard one. This protocol was designed for RSA, but we will use it over EC secp256k1 (Ethereum and Vocdoni standard)."),(0,i.kt)("h2",{id:"salted-csp-keys"},"Salted CSP keys"),(0,i.kt)("p",null,"For making the CSP voter approval valid only for a specific election process (processId) and attached to a specific weight while preserving the privacy, a deterministic key derivation is used. So the CSP is only required to publish a single root public key. The specific per-election keys will be computed independently by all parties (CSP will derive its election private key and the election organizers will derive the election public key). To this end we use the following simple approach (G is the EC generator point):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"PubKeyRoot = PrivKeyRoot * G\nPrivKey2   = PrivkeyRoot +  ProcessId + Weight\nPubKey2    = PubKeyRoot  + (ProcessId + Weight)*G\n")),(0,i.kt)("p",null,"So if PubKey2 becomes the election CSP public key, there is no way the CSP can share signature proofs before the processId is known and there is no way to reuse a CSP signature for a different election process."),(0,i.kt)("h2",{id:"flow-diagram"},"Flow diagram"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://kroki.io/mermaid/svg/eNp9U01PwzAMvfMrfAOEGAJuE0zi44KQJgQSF8TBS9w2aklGkm7avyd2OzWs23pp6z6_vPfsBvptySp6Nlh6_DmBdC3RR6PMEm2ETxfJj6pPH2-j2mPjVK0qNFY-SePlbDaUp1BShKV3ikJ40UdR6QDwziV4u2iMgpo2__ByZ6glj5HA0hpWLhpbjqCJagrYxops0orROAuF8ztCEmqLVRWpeqdDMPPECN6UVQRXgGBZpyZlNAW4W_irGaQuqI3VDNnD0Z3Ty4-uJvsOmNBrYt59HhetaTSbI1BhmV6tbiglr2osadDVUCGy-q4vVtZhv0XY9UQ4_JzWD1r75FzKN5MhCCncTo5padjZQA1t4Mg7H-PUBU76sgezzwyaRb4ib4rNNg8TYIWNGQ0mYJNtxnbOe6aStuGVNnAvQH66GEym58xfzm5Ku6t4bWLVs42nx3JI95lwN8bWE4vouvcF2NpduFwH_wWFIcpKyfzPurg5gp6IcioMbNMV54dykVQxOh_6JWfmbm2ZszeUWUlzydZa9uc0AHb7k-_tH9ykZ4Y=",alt:"flow_diagram_csp"})),(0,i.kt)("h2",{id:"known-problems"},"Known Problems"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Time correlation, the CSP might know which voter is actually casting a vote.\n",(0,i.kt)("em",{parentName:"li"},"Could be solved using a delay mixnet (such as Nymtech)"))),(0,i.kt)("h2",{id:"links"},"Links"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"H. Mala, N. Nezhadansari, ",(0,i.kt)("em",{parentName:"li"},'"New Blind Signature Schemes Based on the (Elliptic Curve) Discrete Logarithm Problem"')," ",(0,i.kt)("a",{parentName:"li",href:"https://sci-hub.st/10.1109/iccke.2013.6682844"},"https://sci-hub.st/10.1109/iccke.2013.6682844")," Implementation: ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/arnaucube/go-blindsecp256k1"},"https://github.com/arnaucube/go-blindsecp256k1")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("em",{parentName:"li"},"EC deterministic derivation key schema PoC implementation"),(0,i.kt)("a",{parentName:"li",href:"https://github.com/p4u/go-eckey-derivation/blob/master/main.go"},"https://github.com/p4u/go-eckey-derivation")),(0,i.kt)("li",{parentName:"ol"},"CSP server implementation ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/vocdoni/blind-csp"},"https://github.com/vocdoni/blind-csp"))))}u.isMDXComponent=!0}}]);