"use strict";(self.webpackChunkdemo=self.webpackChunkdemo||[]).push([[2872],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=c(n),m=r,h=u["".concat(l,".").concat(m)]||u[m]||d[m]||o;return n?a.createElement(h,s(s({ref:t},p),{},{components:n})):a.createElement(h,s({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=u;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var c=2;c<o;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},67864:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var a=n(87462),r=(n(67294),n(3905));const o={},s="Complex Census",i={unversionedId:"sdk/integration-details/census-types/on-chain/complex-census",id:"sdk/integration-details/census-types/on-chain/complex-census",title:"Complex Census",description:"The census3 service makes it easy to create a census based off of the balance holders of a token taken to represent an organization. It is possible, however, to create a token-based census with more complex logic, incorporating balance information from multiple tokens at once.",source:"@site/docs/sdk/integration-details/census-types/on-chain/complex-census.md",sourceDirName:"sdk/integration-details/census-types/on-chain",slug:"/sdk/integration-details/census-types/on-chain/complex-census",permalink:"/sdk/integration-details/census-types/on-chain/complex-census",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"On-chain Token-Based Census",permalink:"/sdk/integration-details/census-types/on-chain/"},next:{title:"Vocdoni Tokens",permalink:"/sdk/integration-details/vocdoni-tokens"}},l={},c=[{value:"Strategies",id:"strategies",level:2},{value:"Predicates",id:"predicates",level:2},{value:"Creating a Census",id:"creating-a-census",level:2}],p={toc:c};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"complex-census"},"Complex Census"),(0,r.kt)("p",null,"The census3 service makes it easy to create a census based off of the balance holders of a token taken to represent an organization. It is possible, however, to create a token-based census with more complex logic, incorporating balance information from multiple tokens at once."),(0,r.kt)("h2",{id:"strategies"},"Strategies"),(0,r.kt)("p",null,"The logic that defines inclusion in a token-based census is called a 'strategy.' For the basic token-holder use case, the strategy is defined solely by that token. ",(0,r.kt)("inlineCode",{parentName:"p"},"createTokenCensus")," chooses the default strategy for that token, so for a basic token-based census you don't need to worry about strategies at all."),(0,r.kt)("p",null,'More complex strategies exist, however, such as "holders of both ',(0,r.kt)("inlineCode",{parentName:"p"},"VOC1")," token AND ",(0,r.kt)("inlineCode",{parentName:"p"},"VOC2"),' token."'),(0,r.kt)("p",null,"Just like checking for supported tokens, you can see a list of the strategies supported by the census3 service:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const strategies = await census3Client.getStrategies();\nconsole.log(JSON.stringify(strategies, null, 4));\n")),(0,r.kt)("p",null,"This will print a long list of strategies. Some of them will be basic strategies for a single token:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'...\n  {\n        "ID": 72,\n        "alias": "Default strategy for token VOC3TEST",\n        "predicate": "VOC3TEST",\n        "uri": "ipfs://bafybeih7rmjsdzqjr6pyjv46jo4kjpl3qfv2yufpdxzmcw2j63z47u6czy",\n        "tokens": {\n            "VOC3TEST": {\n                "ID": "0x9286d95DB5a59306113028EF0BA85bF7068A199F",\n                "chainID": 11155111,\n                "minBalance": "1",\n                "chainAddress": "sep:0x9286d95DB5a59306113028EF0BA85bF7068A199F"\n            }\n        }\n    },\n...\n')),(0,r.kt)("p",null,"Some, on the other hand, will be more complex strategies involving multiple tokens:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'...\n  {\n        "ID": 103,\n        "alias": "gitcoin_onvote_1711040172449",\n        "predicate": "GPS AND:mul (GPS:Discord OR GPS:Github)",\n        "uri": "ipfs://bafybeidopynxc746oorzkh7yvhomcw56w72aaw3klqce4gkjcczc7ry3uu",\n        "tokens": {\n            "GPS": {\n                "ID": "0x000000000000000000000000000000000000006C",\n                "chainID": 1,\n                "minBalance": "16",\n                "chainAddress": "eth:0x000000000000000000000000000000000000006C"\n            },\n            "GPS:Discord": {\n                "ID": "0x000000000000000000000000000000000000006C",\n                "chainID": 1,\n                "minBalance": "1",\n                "chainAddress": "eth:0x000000000000000000000000000000000000006C",\n                "externalID": "Discord"\n            },\n            "GPS:Github": {\n                "ID": "0x000000000000000000000000000000000000006C",\n                "chainID": 1,\n                "minBalance": "1",\n                "chainAddress": "eth:0x000000000000000000000000000000000000006C",\n                "externalID": "Github"\n            }\n        }\n    },\n...\n')),(0,r.kt)("h2",{id:"predicates"},"Predicates"),(0,r.kt)("p",null,"As you can see, there are two main differences between the simple and complex strategies: the ",(0,r.kt)("inlineCode",{parentName:"p"},"predicate")," and the ",(0,r.kt)("inlineCode",{parentName:"p"},"tokens"),". "),(0,r.kt)("p",null,"Predicates are logical operators that define how strategies create a census. There are currently two logical operators (",(0,r.kt)("inlineCode",{parentName:"p"},"AND")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"OR"),"), each with two additional 'powerups' (",(0,r.kt)("inlineCode",{parentName:"p"},"sum")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"mul"),")."),(0,r.kt)("p",null,"Each of the operators uses a different logical strategy for combining token holder balances to create a weighted census:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"},"Operator"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Powerup"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Usage"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"AND")),(0,r.kt)("td",{parentName:"tr",align:"left"}),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"AND")),(0,r.kt)("td",{parentName:"tr",align:"left"},"Holders of both tokens, with a fixed weight of 1.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"OR")),(0,r.kt)("td",{parentName:"tr",align:"left"}),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"OR"),"\xa0"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Holders of either or both tokens, with fixed weight of 1.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"AND")),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"sum")),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"AND:sum")),(0,r.kt)("td",{parentName:"tr",align:"left"},"Holders of both tokens, with a weight adding the token balances.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"AND")),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"mul")),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"AND:mul")),(0,r.kt)("td",{parentName:"tr",align:"left"},"Holders of both tokens, with a weight multiplying the token balances.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"OR")),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"sum")),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"OR:sum")),(0,r.kt)("td",{parentName:"tr",align:"left"},"Holders of either or both tokens, with a weight adding the token balances.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"OR")),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"mul")),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"OR:mul")),(0,r.kt)("td",{parentName:"tr",align:"left"},"Holders of either or both tokens, with a weight multiplying the token balances if both are non-zero, or equaling the balance that is non-zero.")))),(0,r.kt)("p",null,"You can also query the census3 service for a list of available operators:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const operators = await census3Client.getSupportedOperators();\nconsole.log(operators);\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"[\n  {\n    description: 'AND logical operator that returns the common token holders between symbols with fixed balance to 1',\n    tag: 'AND'\n  },\n  {\n    description: 'AND:sum logical operator that returns the common token holders between symbols with the sum of their balances on both tokens',\n    tag: 'AND:sum'\n  },\n  {\n    description: 'AND:mul logical operator that returns the common token holders between symbols with the multiplication of their balances on both tokens',\n    tag: 'AND:mul'\n  },\n  {\n    description: 'OR logical operator that returns the token holders of both symbols with fixed balance to 1',\n    tag: 'OR'\n  },\n  {\n    description: 'OR:sum logical operator that returns the token holders of both symbols with the sum of their balances on both tokens',\n    tag: 'OR:sum'\n  },\n  {\n    description: 'OR:mul logical operator that returns the token holders of both symbols with the multiplication of their balances on both tokens',\n    tag: 'OR:mul'\n  }\n]\n")),(0,r.kt)("p",null,"As seen in the strategy example above, you can combine operators to create complex predicates with many tokens: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'"predicate": "GPS AND:mul (GPS:Discord OR GPS:Github)"\n')),(0,r.kt)("h2",{id:"creating-a-census"},"Creating a Census"),(0,r.kt)("p",null,"The first step in creating a complex census is to create the strategy itself. You can write a predicate with the operators defined above and use the predicate with ",(0,r.kt)("a",{parentName:"p",href:"/sdk/reference/classes/vocdonicensus3client#createstrategy"},(0,r.kt)("inlineCode",{parentName:"a"},"createStrategy()")),". The only requirement is that you include a list of the necessary tokens used by this predicate, including the token ",(0,r.kt)("inlineCode",{parentName:"p"},"ID")," (address), ",(0,r.kt)("inlineCode",{parentName:"p"},"chainID"),", and optionally the ",(0,r.kt)("inlineCode",{parentName:"p"},"minBalance")," (the minimum necessary balance to include a token-holder in a census)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const strategyID = await census3Client.createStrategy('voc_test_strategy', 'VOC3TEST AND VOC3TEST3', {\n  VOC3TEST: {\n    ID: '0x9286d95DB5a59306113028EF0BA85bF7068A199F',\n    chainID: 11155111,\n    minBalance: '1',\n  },\n  VOC3TEST3: {\n    ID: '0x61353Bc49B062EEe99F4768225f4e4f0df5DB1b9',\n    chainID: 11155111,\n    minBalance: '1',\n  },\n});\n")),(0,r.kt)("p",null,"This API call, if successful, returns the ID of the newly-created strategy. You can also use ",(0,r.kt)("inlineCode",{parentName:"p"},"getStrategies()")," again to make sure the strategy is supported. This ID is needed to create the census based off of the strategy:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const censusInfo = await census3Client.createCensus(strategyID);\n")),(0,r.kt)("p",null,"This returns a set of information about the census but cannot be used to directly create an election. To do this, just manually create a ",(0,r.kt)("inlineCode",{parentName:"p"},"PublishedCensus"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const census = new PublishedCensus(\n  censusInfo.merkleRoot,\n  censusInfo.uri,\n  censusInfo.anonymous ? CensusType.ANONYMOUS : CensusType.WEIGHTED,\n  censusInfo.size,\n  BigInt(censusInfo.weight)\n);\n")),(0,r.kt)("p",null,"This census can be used to create an election just like any other. In this case, the census would represent all token-holders of the ",(0,r.kt)("inlineCode",{parentName:"p"},"VOC3TEST")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"VOC3TEST3")," tokens, all with a weight of 1."))}d.isMDXComponent=!0}}]);