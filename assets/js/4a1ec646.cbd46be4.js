"use strict";(self.webpackChunkdemo=self.webpackChunkdemo||[]).push([[5909],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,s=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=c(n),h=i,m=d["".concat(l,".").concat(h)]||d[h]||u[h]||s;return n?a.createElement(m,r(r({ref:t},p),{},{components:n})):a.createElement(m,r({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var s=n.length,r=new Array(s);r[0]=d;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:i,r[1]=o;for(var c=2;c<s;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},23218:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var a=n(87462),i=(n(67294),n(3905));const s={},r="Off-chain Credential Service Provider",o={unversionedId:"sdk/integration-details/census-types/off-chain-csp",id:"sdk/integration-details/census-types/off-chain-csp",title:"Off-chain Credential Service Provider",description:"A Credential Service Provider is an external component that serves as a validator for the identities of voters. An example of this could be a service set up by a municipal government that validates if a given voter is registered, or a forum that validates if a given voter has an active account. With this type of census, voters show proof of registry and receive a cryptographic package from the CSP allowing them to cast a vote.",source:"@site/docs/sdk/integration-details/census-types/off-chain-csp.md",sourceDirName:"sdk/integration-details/census-types",slug:"/sdk/integration-details/census-types/off-chain-csp",permalink:"/sdk/integration-details/census-types/off-chain-csp",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"Census Types",permalink:"/sdk/integration-details/census-types/"},next:{title:"Off-chain Merkle Tree",permalink:"/sdk/integration-details/census-types/off-chain-tree"}},l={},c=[{value:"Tutorial",id:"tutorial",level:2},{value:"Census",id:"census",level:3},{value:"Election",id:"election",level:3},{value:"Voting",id:"voting",level:3},{value:"Anonymity",id:"anonymity",level:2}],p={toc:c};function u(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"off-chain-credential-service-provider"},"Off-chain Credential Service Provider"),(0,i.kt)("p",null,"A Credential Service Provider is an external component that serves as a validator for the identities of voters. An example of this could be a service set up by a municipal government that validates if a given voter is registered, or a forum that validates if a given voter has an active account. With this type of census, voters show proof of registry and receive a cryptographic package from the CSP allowing them to cast a vote. "),(0,i.kt)("admonition",{title:"anonymous",type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"CSP census elections have the option of full anonymity with the use of ",(0,i.kt)("a",{parentName:"p",href:"/protocol/Census/off-chain-csp#blind-signatures"},"Blind Signatures"),". ")),(0,i.kt)("p",null,"Because using an off-chain CSP census requires a custom CSP for each use-case, it is not ready to use out-of-the-box. If you are interested in setting up a CSP election, please ",(0,i.kt)("a",{parentName:"p",href:"https://chat.vocdoni.io"},"reach out to us")," for help."),(0,i.kt)("h2",{id:"tutorial"},"Tutorial"),(0,i.kt)("p",null,"You can check out a full working example of this tutorial ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/vocdoni/vocdoni-sdk/tree/examples/token-based/examples/csp"},"here")),(0,i.kt)("p",null,'This tutorial uses an example Credential Service Provider that "verifies" voters with a simple arithmetic problem. For a real use-case you need to reach out to us for help with setting up a CSP that suits your needs.'),(0,i.kt)("h3",{id:"census"},"Census"),(0,i.kt)("p",null,"Once a CSP has been set up, you should have a ",(0,i.kt)("inlineCode",{parentName:"p"},"URL")," and a ",(0,i.kt)("inlineCode",{parentName:"p"},"Public Key")," belonging to that CSP. These parameters are used to create a ",(0,i.kt)("a",{parentName:"p",href:"/sdk/reference/classes/CspCensus"},(0,i.kt)("inlineCode",{parentName:"a"},"CspCensus")),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const cspCensus = new CspCensus(CSP_PUBKEY, CSP_URL);\n")),(0,i.kt)("admonition",{title:"csp public key",type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"Make sure that your are using the correct public key for your CSP. The protocol cannot tell if the public key is correct, but you will have a signature error when casting votes with an incorrect CSP public key.")),(0,i.kt)("h3",{id:"election"},"Election"),(0,i.kt)("p",null,"This census can then be used to create an election like any other. The only restriction is you must assign a ",(0,i.kt)("inlineCode",{parentName:"p"},"maxCensusSize")," to the election."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const election = Election.from({\n    title: 'Election title',\n    description: 'Election description',\n    header: 'https://source.unsplash.com/random',\n    endDate: new Date().getTime() + 100000000,\n    maxCensusSize: 200,\n    census: cspCensus,\n  });\n")),(0,i.kt)("p",null,"From this point on you can create the election as you would with any other census type. "),(0,i.kt)("h3",{id:"voting"},"Voting"),(0,i.kt)("p",null,"The next step is requesting a signature from the CSP for each voter before casting their vote. In a real application, this might be done interactively with user input (like address or phone number), or it could be handled automatically using existing information (like a user login info, or a voter ID number)."),(0,i.kt)("p",null,"There can be multiple steps in order to validate a voter. This authorization is done in discrete steps which should be known for a CSP. We can also get a short description of the required steps with ",(0,i.kt)("a",{parentName:"p",href:"/sdk/reference/classes/VocdoniSDKClient#cspinfo"},(0,i.kt)("inlineCode",{parentName:"a"},"client.cspInfo")),". "),(0,i.kt)("admonition",{title:"csp info",type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Before getting the CSP info, the client CSP service needs to know which CSP to communiate with. The CSP url is set automatically when voting, but you can also use ",(0,i.kt)("inlineCode",{parentName:"p"},"setUrlFromElection"),".")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"client.cspService.setUrlFromElection(election);\nconst info = await client.cspInfo();\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "title": "Simple math challenge",\n    "signatureType": [\n      "blind",\n        "ecdsa",\n        "sharedkey"\n    ],\n    "authType": "auth",\n    "authSteps": [\n      {\n        "title": "Name",\n            "type": "text"\n        },\n        {\n          "title": "Solution",\n            "type": "int4"\n        }\n    ]\n}\n')),(0,i.kt)("p",null,'For our example CSP, there are two steps. The first step involves sending a "name" (really any string). The second step requires the user to solve a simple math problem. '),(0,i.kt)("p",null,"The authorization steps are completed one-by-one with ",(0,i.kt)("a",{parentName:"p",href:"/sdk/reference/classes/VocdoniSDKClient#cspstep"},(0,i.kt)("inlineCode",{parentName:"a"},"client.cspStep")),'. This function sends an API call to the given CSP to perform a predefined "authentication step". A step could be validating a name, sending an authentication token, or really anything else. Non-final steps return a ',(0,i.kt)("a",{parentName:"p",href:"/sdk/reference/interfaces/ICspIntermediateStepResponse"},(0,i.kt)("inlineCode",{parentName:"a"},"ICspIntermediateStepResponse"))," object containing an ",(0,i.kt)("inlineCode",{parentName:"p"},"authToken")," and arbitrary ",(0,i.kt)("inlineCode",{parentName:"p"},"response")," data."),(0,i.kt)("p",null,'For our example first step, we just need to send some "name" string.'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const step0 = (await client.cspStep(0, ['Name test'])) as ICspIntermediateStepResponse;\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "authToken": "280b3b5f-d982-4277-aa73-bd2d3b0d0d8c",\n    "response": [\n        "319",\n        "303"\n    ]\n}\n')),(0,i.kt)("p",null,"In this case, the second (and final) step asks us to add together the two values from the response to ",(0,i.kt)("inlineCode",{parentName:"p"},"step0"),'. We do this by computing the sum and then using this sum as the "challenge" for the next step. We also include the ',(0,i.kt)("inlineCode",{parentName:"p"},"authToken")," from the prior step so that the CSP knows we are validating for the same voter."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const challenge = step0.response.reduce((accumulator, value) => +accumulator + +value, 0).toString();\nconst step1 = (await client.cspStep(1, [challenge], step0.authToken)) as ICspFinalStepResponse;\n")),(0,i.kt)("p",null,"Once the predefined set of steps has been performed successfully, the final step should return a ",(0,i.kt)("a",{parentName:"p",href:"/sdk/reference/interfaces/ICspFinalStepResponse"},(0,i.kt)("inlineCode",{parentName:"a"},"ICspFinalStepResponse"))," object containing a ",(0,i.kt)("inlineCode",{parentName:"p"},"token")," registered to the verified voter."),(0,i.kt)("p",null,"This token represents a 'permission slip' allowing a user to vote but it cannot be used to cast a vote directly. First, the voter must be represented by a wallet address, just like in the typical off-chain tree census example. This wallet can belong to the user and be saved somewhere, but for the example we can just create a random address:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const voter = Wallet.createRandom();\n")),(0,i.kt)("p",null,"We then send this address to the CSP, along with the token validating that this voter is validated. The CSP checks that the token is valid and unique, computes a signature on the voter's address, and sends that signature back to the client."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const signature = await client.cspSign(voter.address, step1.token);\n")),(0,i.kt)("p",null,"We can now create a ",(0,i.kt)("a",{parentName:"p",href:"/sdk/reference/classes/cspvote"},(0,i.kt)("inlineCode",{parentName:"a"},"cspVote"))," using this ",(0,i.kt)("inlineCode",{parentName:"p"},"signature")," as the vote proof and then submit it as usual:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const vote = client.cspVote(new Vote([Math.round(Math.random())]), signature);\nawait client.submitVote(vote);\n")),(0,i.kt)("h2",{id:"anonymity"},"Anonymity"),(0,i.kt)("p",null,"Credential Service Provider elections provide strong anonymity with the use of ",(0,i.kt)("a",{parentName:"p",href:"/protocol/Census/off-chain-csp#blind-signatures"},"Blind Signatures"),'. If blind signatures are enabled, the client "blinds" the user\'s address before sending it with the token to be signed by the CSP. This is the default behavior of the SDK. The CSP is then able to validate the token and sign the "blinded" payload without seeing the actual voter address. This signature is sent back to the client, which then un-blinds the signature. The blind-signatures protocol means that this signature is only valid for this specific voter address, but the CSP has no way of associating it with the blinded payload it originally signed. Thus, the voter cannot be associated with the validation token they used to request the blind signature. The user is thus able cast their vote signed by the CSP without their identity being traced to that vote by anybody, including the CSP.'),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://chat.vocdoni.io"},"Ask us")," if you would like to try setting up at CSP that can compute blind signatures. "))}u.isMDXComponent=!0}}]);