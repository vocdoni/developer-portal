"use strict";(self.webpackChunkdemo=self.webpackChunkdemo||[]).push([[2038],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},u=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,s=e.originalType,c=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),p=l(n),d=o,f=p["".concat(c,".").concat(d)]||p[d]||h[d]||s;return n?r.createElement(f,a(a({ref:t},u),{},{components:n})):r.createElement(f,a({ref:t},u))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var s=n.length,a=new Array(s);a[0]=p;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:o,a[1]=i;for(var l=2;l<s;l++)a[l]=n[l];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},46596:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>l});var r=n(87462),o=(n(67294),n(3905));const s={},a="The Census",i={unversionedId:"protocol/Census/census-overview",id:"protocol/Census/census-overview",title:"The Census",description:"In Vocdoni, a census of identities can be represented in one of three ways. For Ethereum-based processes, in which eligible voters are represented by Ethereum addresses holding a specific token, an on-chain (ERC-20) census is used. In cases where a central authority wants to manually validate each voter at the time of voting, off-chain credential service provider is used. For all other voting processes (organizations that are not represented as DAOs), an off-chain tree census is used.",source:"@site/docs/protocol/03-Census/01-census-overview.md",sourceDirName:"protocol/03-Census",slug:"/protocol/Census/census-overview",permalink:"/protocol/Census/census-overview",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{},sidebar:"protocol",previous:{title:"Blind Signatures",permalink:"/protocol/Anonymous/blind-signatures"},next:{title:"On-Chain Census",permalink:"/protocol/Census/on-chain"}},c={},l=[{value:"On-Chain Based Census (Ethereum ERC-20)",id:"on-chain-based-census-ethereum-erc-20",level:2},{value:"Off-Chain CSP Based Census (Credential Service Provider)",id:"off-chain-csp-based-census-credential-service-provider",level:2},{value:"Off-Chain Tree Based Census (Merkle Tree)",id:"off-chain-tree-based-census-merkle-tree",level:2}],u={toc:l};function h(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"the-census"},"The Census"),(0,o.kt)("p",null,"In Vocdoni, a census of identities can be represented in one of three ways. For Ethereum-based processes, in which eligible voters are represented by Ethereum addresses holding a specific token, an ",(0,o.kt)("a",{parentName:"p",href:"on-chain"},"on-chain")," (ERC-20) census is used. In cases where a central authority wants to manually validate each voter at the time of voting, ",(0,o.kt)("a",{parentName:"p",href:"off-chain-csp"},"off-chain credential service provider")," is used. For all other voting processes (organizations that are not represented as DAOs), an ",(0,o.kt)("a",{parentName:"p",href:"off-chain-tree"},"off-chain tree")," census is used. "),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"Between the three of these census methods, an incredible range of use-cases and third-party integrations for voter eligibility management is possible. Furthermore, the flexibility of the voting protocol is designed to allow more census types to be easily added in the future.")),(0,o.kt)("p",null,"When a voting process is created, the Census Origin is set to signify which type of census the process should expect to use. "),(0,o.kt)("h2",{id:"on-chain-based-census-ethereum-erc-20"},"On-Chain Based Census (Ethereum ERC-20)"),(0,o.kt)("p",null,"On-chain census allow the set of eligible voters to be expressed as a weighted census of holders of a specific token on Ethereum. There is only one entity per Ethereum token, where the address of that entity is the contract address of the given token. "),(0,o.kt)("p",null,"To this end, Ethereum Storage Proofs are used. "),(0,o.kt)("p",null,"Anyone can permissionlessly register a token to the Storage Proof Smart Contract, incurring some gas cost. Then any holder of the token can create a voting process for that token and set the proper census origin value to signal the use of an on-chain census. The Census Merkle Root is the Ethereum Root Hash at a given block height, and any user can request a Merkle Proof that their address holds tokens on the target ERC20 smart contract. They can then provide this proof to vote on processes for the entity representing that token address. Weighted processes enable users to employ a voting power that is proportionate to the number of tokens they hold."),(0,o.kt)("p",null,"Technical details for on-chain census can be found at ",(0,o.kt)("a",{parentName:"p",href:"on-chain"},"On-Chain Census"),"."),(0,o.kt)("h2",{id:"off-chain-csp-based-census-credential-service-provider"},"Off-Chain CSP Based Census (Credential Service Provider)"),(0,o.kt)("p",null,"In order to support frequent modifications to the census of an ongoing process and to bring more flexibility to the Vocdoni stack, a census based on Credential Service Providers (CSP) or Certificate Authorities (CAs) is implemented. This method allows organizations to set up a centralized authority that provides credentials to each voter, one-by-one, based on any arbitrary criteria decided by the organization. "),(0,o.kt)("p",null,"Technical details for off-chain CSP census can be found at ",(0,o.kt)("a",{parentName:"p",href:"off-chain-csp"},"Off-Chain CSP Census"),"."),(0,o.kt)("h2",{id:"off-chain-tree-based-census-merkle-tree"},"Off-Chain Tree Based Census (Merkle Tree)"),(0,o.kt)("p",null,"An off-chain tree census allows organizations to centrally manage the set of members who can vote on any given process. Organizations can generate the Census Merkle Tree itself with the help of the Census Service, but they are responsible for manually generating a list of voters. ",(0,o.kt)("a",{parentName:"p",href:"https://vocdoni.app"},"Vocdoni.app")," currently provides a CSV-based census mechanism."),(0,o.kt)("p",null,"Technical details for off-chain tree census can be found at ",(0,o.kt)("a",{parentName:"p",href:"off-chain-tree"},"Off-Chain Tree Census"),"."))}h.isMDXComponent=!0}}]);