"use strict";(self.webpackChunkdemo=self.webpackChunkdemo||[]).push([[3306],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>f});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),h=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=h(e.components);return r.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=h(n),f=o,d=u["".concat(l,".").concat(f)]||u[f]||p[f]||a;return n?r.createElement(d,i(i({ref:t},c),{},{components:n})):r.createElement(d,i({ref:t},c))}));function f(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var h=2;h<a;h++)i[h]=n[h];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},13727:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>h});var r=n(87462),o=(n(67294),n(3905));const a={},i="Off-Chain Tree Census",s={unversionedId:"protocol/Census/off-chain-tree",id:"protocol/Census/off-chain-tree",title:"Off-Chain Tree Census",description:"The census itself is represented as a binary Merkle Tree, where the leaves of the tree contain the public keys of all eligible voters, hashed.",source:"@site/docs/protocol/03-Census/04-off-chain-tree.md",sourceDirName:"protocol/03-Census",slug:"/protocol/Census/off-chain-tree",permalink:"/protocol/Census/off-chain-tree",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{},sidebar:"protocol",previous:{title:"Off-Chain CSP Census",permalink:"/protocol/Census/off-chain-csp"},next:{title:"Ballot Protocol",permalink:"/protocol/ballot"}},l={},h=[{value:"Creating &amp; publishing the census",id:"creating--publishing-the-census",level:3},{value:"Accessing the census",id:"accessing-the-census",level:3}],c={toc:h};function p(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"off-chain-tree-census"},"Off-Chain Tree Census"),(0,o.kt)("p",null,"The census itself is represented as a binary ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Merkle_tree"},"Merkle Tree"),", where the leaves of the tree contain the public keys of all eligible voters, hashed. "),(0,o.kt)("mermaid",{value:"graph TD;\nstyle Root fill:#EBAE9A,stroke:#333,stroke-width:2px\n\nRoot--\x3eH1\nRoot--\x3eH2\nH1--\x3eH3\nH1--\x3eH4\nH2--\x3eH5\nH2--\x3eH6\nH3-.->HashPubKey1\nH4-.->Empty\nH5-.->HashPubKey2\nH6-.->HashPubKey3"}),(0,o.kt)("p",null,"A Merkle Tree can efficiently prove that a leaf belongs to the tree. For a tree of size ",(0,o.kt)("inlineCode",{parentName:"p"},"N")," elements, only ",(0,o.kt)("inlineCode",{parentName:"p"},"log(N)")," elements are needed to generate a proof. A tree with 1 million leaves, for example, would only need 20 hashes to prove the inclusion of any one leaf. "),(0,o.kt)("p",null,"The tree structure is made of nodes. Terminal nodes contain the actual values; every other node contains the hash of its two children. If a leaf is updated, all its parent nodes are affected."),(0,o.kt)("p",null,"A ",(0,o.kt)("strong",{parentName:"p"},"prover")," is able to prove the inclusion of any leaf of the Merkle Tree to a ",(0,o.kt)("strong",{parentName:"p"},"verifier"),":"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("strong",{parentName:"li"},"verifier")," only needs to know the Root Hash"),(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("strong",{parentName:"li"},"prover")," only needs to provide the Leaf and its Sibling, as well as the sibling of each of its ancestors (hence, ",(0,o.kt)("inlineCode",{parentName:"li"},"log(N)")," elements).")),(0,o.kt)("p",null,"This means that, in the case of our example Voting Merkle Tree, the owner of PubKey1 only needs ",(0,o.kt)("inlineCode",{parentName:"p"},"HashPubKey1 + H4 + H2")," (highlighted in green on the graph below) to prove that their key is part of the Merkle Tree, and therefore that their public key is in the voter census. "),(0,o.kt)("mermaid",{value:"graph TD\nHP1{{HashPubKey1}}\nHP2{{H2}}\nHP4{{H4}}\n\nstyle Root fill:#EBAE9A,stroke:#333,stroke-width:2px\nstyle HP1 fill:#98fb98,stroke:#333,stroke-width:2px\nstyle HP2 fill:#98fb98,stroke:#333,stroke-width:2px\nstyle HP4 fill:#98fb98,stroke:#333,stroke-width:2px\n\nRoot--\x3eH1\nRoot--\x3eHP2\nH1--\x3eH3\nH1--\x3eHP4\nHP2--\x3eH5\nHP2--\x3eH6\nH3-.->HP1\nHP4-.->Empty\nH5-.->HashPubKey2\nH6-.->HashPubKey3"}),(0,o.kt)("p",null,"To verify this proof, the verifier simply computes ",(0,o.kt)("inlineCode",{parentName:"p"},"hash( hash( hash(HashPubKey1) + H4 ) + H2 )")," and compares this result with the known Root hash of the Merkle Tree."),(0,o.kt)("p",null,"This Merkle Proof design allows voters to prove census inclusion without knowing any other voters' keys, and with a computation time that is logarithmically proportionate to the census size. "),(0,o.kt)("p",null,"Vocdoni stores a hash of public keys instead of public keys themselves to provide an additional privacy layer when publishing the census."),(0,o.kt)("h3",{id:"creating--publishing-the-census"},"Creating & publishing the census"),(0,o.kt)("p",null,"Any organization which does not wish to use the ",(0,o.kt)("a",{parentName:"p",href:"on-chain"},"on-chain census mechanism")," is required to generate and publish a census Merkle Tree in order to host a voting process on the Voting Blockchain. The method for managing and filtering users and generating the Merkle Tree, however, is up to integrators of the Voting Protocol. The census module is further documented on the census integration page."),(0,o.kt)("h3",{id:"accessing-the-census"},"Accessing the census"),(0,o.kt)("p",null,"The Gateways deployed by Vocdoni and third parties constantly monitor the Process Smart Contract. Upon identifying a new process, they will fetch and import that process' Census Merkle Tree. At this point, users can use any available Gateway to check whether they are eligible for voting and then fetch their Merkle Proof (this as well may be handled by the client implementation)"),(0,o.kt)("p",null,"Users with a valid Merkle Proof can efficiently show that their key belongs to a large census by providing a very small fraction of the whole tree."))}p.isMDXComponent=!0}}]);