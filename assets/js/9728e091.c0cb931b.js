"use strict";(self.webpackChunkdemo=self.webpackChunkdemo||[]).push([[5470],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>f});var r=n(67294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,s=function(e,t){if(null==e)return{};var n,r,s={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,s=e.mdxType,a=e.originalType,c=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),p=l(n),f=s,h=p["".concat(c,".").concat(f)]||p[f]||d[f]||a;return n?r.createElement(h,i(i({ref:t},u),{},{components:n})):r.createElement(h,i({ref:t},u))}));function f(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var a=n.length,i=new Array(a);i[0]=p;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:s,i[1]=o;for(var l=2;l<a;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},30775:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>l});var r=n(87462),s=(n(67294),n(3905));const a={},i="Off-chain Merkle Tree",o={unversionedId:"sdk/integration-details/census-types/off-chain-tree",id:"sdk/integration-details/census-types/off-chain-tree",title:"Off-chain Merkle Tree",description:"This is the most basic census type, is the default when creating an election, and is the one used in the SDK tutorial. In this scheme, the census is essentially a basic list of voter, with some behind-the-scenes cryptography. With an off-train tree census, voters are added as wallet addresses using census.add().",source:"@site/docs/sdk/integration-details/census-types/off-chain-tree.md",sourceDirName:"sdk/integration-details/census-types",slug:"/sdk/integration-details/census-types/off-chain-tree",permalink:"/sdk/integration-details/census-types/off-chain-tree",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"Off-chain Credential Service Provider",permalink:"/sdk/integration-details/census-types/off-chain-csp"},next:{title:"On-chain Token-Based Census",permalink:"/sdk/integration-details/census-types/on-chain/"}},c={},l=[{value:"Anonymity",id:"anonymity",level:2}],u={toc:l};function d(e){let{components:t,...n}=e;return(0,s.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"off-chain-merkle-tree"},"Off-chain Merkle Tree"),(0,s.kt)("p",null,"This is the most basic census type, is the default when creating an election, and is the one used in the SDK tutorial. In this scheme, the census is essentially a basic list of voter, with some behind-the-scenes cryptography. With an off-train tree census, voters are added as wallet addresses using ",(0,s.kt)("a",{parentName:"p",href:"/sdk/reference/classes/PlainCensus#add"},(0,s.kt)("inlineCode",{parentName:"a"},"census.add()")),". "),(0,s.kt)("p",null,"This is the census type used in the ",(0,s.kt)("a",{parentName:"p",href:"/sdk/tutorial"},"SDK Tutorial"),". Follow along or look at the tutorial code for basic usage of the Merkle tree census."),(0,s.kt)("p",null,"Off-chain tree census can be created as ",(0,s.kt)("a",{parentName:"p",href:"/sdk/reference/classes/PlainCensus"},(0,s.kt)("inlineCode",{parentName:"a"},"PlainCensus"))," or ",(0,s.kt)("a",{parentName:"p",href:"/sdk/reference/classes/WeightedCensus"},(0,s.kt)("inlineCode",{parentName:"a"},"WeightedCensus")),". If a weighted census is used, voters can be assigned a weight which proportionally determines the power of their vote: "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"weightedCensus.add([\n    {\n      key: address1,\n      weight: BigInt(1),\n    },\n    {\n      key: address2,\n      // This voter will have 100x the vote power as voter1. This is not a very equitable election.\n      weight: BigInt(100),\n    },\n  ]);\n")),(0,s.kt)("h2",{id:"anonymity"},"Anonymity"),(0,s.kt)("p",null,"Complete cryptographic anonymity is possible alongside universal verifiability with anonymous Merkle tree-based censuses. This is possible due to a cutting-edge technology called zk-SNARKs. The protocol-level design is detailed ",(0,s.kt)("a",{parentName:"p",href:"/protocol/anonymity/zk-census-proof"},"here"),"."),(0,s.kt)("p",null,"For an anonymous off-chain tree election, the election must be created with the option "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"electionType: {\n  anonymous: true\n}\n")),(0,s.kt)("p",null,"In this case, votes must also be cast as ",(0,s.kt)("a",{parentName:"p",href:"/sdk/reference/classes/AnonymousVote"},(0,s.kt)("inlineCode",{parentName:"a"},"AnonymousVote")),"s. The cryptography needed for anonymous voting is very different from typical voting, but this is all handled by the SDK without any other changes needed."))}d.isMDXComponent=!0}}]);