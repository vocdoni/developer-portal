"use strict";(self.webpackChunkdemo=self.webpackChunkdemo||[]).push([[2816],{2816:(e,t,s)=>{s.r(t),s.d(t,{SetupWorkerApi:()=>Le,setupWorker:()=>xe});var r=s(80912),n=s(59336);var o=s(786);var i=s(6700);async function a(e,t,s,n,a,l){if(a.emit("request:start",{request:e,requestId:t}),"bypass"===e.headers.get("x-msw-intention"))return a.emit("request:end",{request:e,requestId:t}),void l?.onPassthroughResponse?.(e);const c=await(async e=>{try{const t=await e().catch((e=>{throw e}));return{error:null,data:t}}catch(F){return{error:F,data:null}}})((()=>(async({request:e,requestId:t,handlers:s,resolutionContext:r})=>{let n=null,o=null;for(const i of s)if(o=await i.run({request:e,requestId:t,resolutionContext:r}),null!==o&&(n=i),o?.response)break;return n?{handler:n,parsedResult:o?.parsedResult,response:o?.response}:null})({request:e,requestId:t,handlers:s,resolutionContext:l?.resolutionContext})));if(c.error)throw a.emit("unhandledException",{error:c.error,request:e,requestId:t}),c.error;if(!c.data)return await async function(e,t="warn"){const s=new URL(e.url),n=(0,o.F)(s),i=`intercepted a request without a matching request handler:\n\n  \u2022 ${e.method} ${n}\n\nIf you still wish to intercept this unhandled request, please create a request handler for it.\nRead more: https://mswjs.io/docs/getting-started/mocks`;function a(e){switch(e){case"error":throw r.e.error("Error: %s",i),new Error(r.e.formatMessage('Cannot bypass a request when using the "error" strategy for the "onUnhandledRequest" option.'));case"warn":r.e.warn("Warning: %s",i);break;case"bypass":break;default:throw new Error(r.e.formatMessage('Failed to react to an unhandled request: unknown strategy "%s". Please provide one of the supported strategies ("bypass", "warn", "error") or a custom callback function as the value of the "onUnhandledRequest" option.',e))}}"function"!=typeof t?"file:"!==s.protocol&&a(t):t(e,{warning:a.bind(null,"warn"),error:a.bind(null,"error")})}(e,n.onUnhandledRequest),a.emit("request:unhandled",{request:e,requestId:t}),a.emit("request:end",{request:e,requestId:t}),void l?.onPassthroughResponse?.(e);const{response:u}=c.data;if(!u)return a.emit("request:end",{request:e,requestId:t}),void l?.onPassthroughResponse?.(e);if(302===u.status&&"passthrough"===u.headers.get("x-msw-intention"))return a.emit("request:end",{request:e,requestId:t}),void l?.onPassthroughResponse?.(e);!function(e,t){i.h.add({...e,url:e.url.toString()},t),i.h.persist()}(e,u),a.emit("request:match",{request:e,requestId:t});const h=c.data,d=l?.transformResponse?.(u)||u;return l?.onMockedResponse?.(d,h),a.emit("request:end",{request:e,requestId:t}),d}var l=s(95002),c=s(36726);class u{subscriptions=[];async dispose(){await Promise.all(this.subscriptions.map((e=>e())))}}class h{constructor(e){this.initialHandlers=e,this.handlers=[...e]}handlers;prepend(e){this.handlers.unshift(...e)}reset(e){this.handlers=e.length>0?[...e]:[...this.initialHandlers]}currentHandlers(){return this.handlers}}class d extends u{handlersController;emitter;publicEmitter;events;constructor(...e){super(),(0,l.kG)(this.validateHandlers(e),r.e.formatMessage("Failed to apply given request handlers: invalid input. Did you forget to spread the request handlers Array?")),this.handlersController=new h(e),this.emitter=new c.Q,this.publicEmitter=new c.Q,function(e,t){const s=e.emit;if(s._isPiped)return;const r=function(e,...r){return t.emit(e,...r),s.call(this,e,...r)};r._isPiped=!0,e.emit=r}(this.emitter,this.publicEmitter),this.events=this.createLifeCycleEvents(),this.subscriptions.push((()=>{this.emitter.removeAllListeners(),this.publicEmitter.removeAllListeners()}))}validateHandlers(e){return e.every((e=>!Array.isArray(e)))}use(...e){(0,l.kG)(this.validateHandlers(e),r.e.formatMessage('Failed to call "use()" with the given request handlers: invalid input. Did you forget to spread the array of request handlers?')),this.handlersController.prepend(e)}restoreHandlers(){this.handlersController.currentHandlers().forEach((e=>{e.isUsed=!1}))}resetHandlers(...e){this.handlersController.reset(e)}listHandlers(){return function(e){const t=[...e];return Object.freeze(t),t}(this.handlersController.currentHandlers())}createLifeCycleEvents(){return{on:(...e)=>this.publicEmitter.on(...e),removeListener:(...e)=>this.publicEmitter.removeListener(...e),removeAllListeners:(...e)=>this.publicEmitter.removeAllListeners(...e)}}}function p(e){return null!=e&&"object"==typeof e&&!Array.isArray(e)}function g(e,t){return Object.entries(t).reduce(((e,[t,s])=>{const r=e[t];return Array.isArray(r)&&Array.isArray(s)?(e[t]=r.concat(s),e):p(r)&&p(s)?(e[t]=g(r,s),e):(e[t]=s,e)}),Object.assign({},e))}var f=s(34155),m=/(%?)(%([sdijo]))/g;function v(e,...t){if(0===t.length)return e;let s=0,r=e.replace(m,((e,r,n,o)=>{const i=function(e,t){switch(t){case"s":return e;case"d":case"i":return Number(e);case"j":return JSON.stringify(e);case"o":{if("string"==typeof e)return e;const t=JSON.stringify(e);return"{}"===t||"[]"===t||/^\[object .+?\]$/.test(t)?e:t}}}(t[s],o);return r?e:(s++,i)}));return s<t.length&&(r+=` ${t.slice(s).join(" ")}`),r=r.replace(/%{2,2}/g,"%"),r}var y=class extends Error{constructor(e,...t){super(e),this.message=e,this.name="Invariant Violation",this.message=v(e,...t),function(e){if(!e.stack)return;const t=e.stack.split("\n");t.splice(1,2),e.stack=t.join("\n")}(this)}},w=(e,t,...s)=>{if(!e)throw new y(t,...s)};function b(){if("undefined"!=typeof navigator&&"ReactNative"===navigator.product)return!0;if(void 0!==f){const e=f.type;return"renderer"!==e&&"worker"!==e&&!(!f.versions||!f.versions.node)}return!1}w.as=(e,t,s,...r)=>{if(!t){const t=0===r.length?s:v(s,r);let o;try{o=Reflect.construct(e,[t])}catch(n){o=e(t)}throw o}};var q=async e=>{try{return{error:null,data:await e().catch((e=>{throw e}))}}catch(t){return{error:t,data:null}}};function k(e,t,s){return[e.active,e.installing,e.waiting].filter((e=>null!=e)).find((e=>s(e.scriptURL,t)))||null}var R=async(e,t={},s)=>{const n=new URL(e,location.href).href;const o=await navigator.serviceWorker.getRegistrations().then((e=>e.filter((e=>k(e,n,s)))));!navigator.serviceWorker.controller&&o.length>0&&location.reload();const[i]=o;if(i)return i.update().then((()=>[k(i,n,s),i]));const a=await q((async()=>{const r=await navigator.serviceWorker.register(e,t);return[k(r,n,s),r]}));if(a.error){if(a.error.message.includes("(404)")){const e=new URL(t?.scope||"/",location.href);throw new Error(r.e.formatMessage(`Failed to register a Service Worker for scope ('${e.href}') with script ('${n}'): Service Worker script does not exist at the given path.\n\nDid you forget to run "npx msw init <PUBLIC_DIR>"?\n\nLearn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`))}throw new Error(r.e.formatMessage("Failed to register the Service Worker:\n\n%s",a.error.message))}return a.data};function E(e={}){if(e.quiet)return;const t=e.message||"Mocking enabled.";console.groupCollapsed(`%c${r.e.formatMessage(t)}`,"color:orangered;font-weight:bold;"),console.log("%cDocumentation: %chttps://mswjs.io/docs","font-weight:bold","font-weight:normal"),console.log("Found an issue? https://github.com/mswjs/msw/issues"),e.workerUrl&&console.log("Worker script URL:",e.workerUrl),e.workerScope&&console.log("Worker scope:",e.workerScope),console.groupEnd()}function L(e){if(!["HEAD","GET"].includes(e.method))return e.body}var x=(e,t)=>async(s,o)=>{const i=new class{constructor(e){this.port=e}postMessage(e,...t){const[s,r]=t;this.port.postMessage({type:e,data:s},{transfer:r})}}(s.ports[0]),l=o.payload.id,c=(u=o.payload,new Request(u.url,{...u,body:L(u)}));var u;const h=c.clone(),d=c.clone();n.Z.cache.set(c,d),e.requests.set(l,d);try{await a(c,l,e.getRequestHandlers(),t,e.emitter,{onPassthroughResponse(){i.postMessage("PASSTHROUGH")},async onMockedResponse(s,{handler:r,parsedResult:n}){const o=s.clone(),a=s.clone(),l=function(e){return{status:e.status,statusText:e.statusText,headers:Object.fromEntries(e.headers.entries())}}(s);if(e.supports.readableStreamTransfer){const e=s.body;i.postMessage("MOCK_RESPONSE",{...l,body:e},e?[e]:void 0)}else{const e=null===s.body?null:await o.arrayBuffer();i.postMessage("MOCK_RESPONSE",{...l,body:e})}t.quiet||e.emitter.once("response:mocked",(()=>{r.log({request:h,response:a,parsedResult:n})}))}})}catch(p){p instanceof Error&&(r.e.error('Uncaught exception in the request handler for "%s %s":\n\n%s\n\nThis exception has been gracefully handled as a 500 response, however, it\'s strongly recommended to resolve this error, as it indicates a mistake in your code. If you wish to mock an error response, please see this guide: https://mswjs.io/docs/recipes/mocking-error-responses',c.method,c.url,p.stack??p),i.postMessage("MOCK_RESPONSE",{status:500,statusText:"Request Handler Error",headers:{"Content-Type":"application/json"},body:JSON.stringify({name:p.name,message:p.message,stack:p.stack})}))}};var T=new TextEncoder;var S=new Set([101,103,204,205,304]);function P(e){return S.has(e)}var I=Symbol("isPatchedModule"),M=Object.defineProperty,C={};function A(e){return`\x1b[33m${e}\x1b[0m`}function O(e){return`\x1b[34m${e}\x1b[0m`}function H(e){return`\x1b[90m${e}\x1b[0m`}function W(e){return`\x1b[31m${e}\x1b[0m`}function j(e){return`\x1b[32m${e}\x1b[0m`}((e,t)=>{for(var s in t)M(e,s,{get:t[s],enumerable:!0})})(C,{blue:()=>O,gray:()=>H,green:()=>j,red:()=>W,yellow:()=>A});var D=b(),N=class{constructor(e){this.name=e,this.prefix=`[${this.name}]`;const t=G("DEBUG"),s=G("LOG_LEVEL");"1"===t||"true"===t||void 0!==t&&this.name.startsWith(t)?(this.debug=X(s,"debug")?U:this.debug,this.info=X(s,"info")?U:this.info,this.success=X(s,"success")?U:this.success,this.warning=X(s,"warning")?U:this.warning,this.error=X(s,"error")?U:this.error):(this.info=U,this.success=U,this.warning=U,this.error=U,this.only=U)}prefix;extend(e){return new N(`${this.name}:${e}`)}debug(e,...t){this.logEntry({level:"debug",message:H(e),positionals:t,prefix:this.prefix,colors:{prefix:"gray"}})}info(e,...t){this.logEntry({level:"info",message:e,positionals:t,prefix:this.prefix,colors:{prefix:"blue"}});const s=new _;return(e,...t)=>{s.measure(),this.logEntry({level:"info",message:`${e} ${H(`${s.deltaTime}ms`)}`,positionals:t,prefix:this.prefix,colors:{prefix:"blue"}})}}success(e,...t){this.logEntry({level:"info",message:e,positionals:t,prefix:`\u2714 ${this.prefix}`,colors:{timestamp:"green",prefix:"green"}})}warning(e,...t){this.logEntry({level:"warning",message:e,positionals:t,prefix:`\u26a0 ${this.prefix}`,colors:{timestamp:"yellow",prefix:"yellow"}})}error(e,...t){this.logEntry({level:"error",message:e,positionals:t,prefix:`\u2716 ${this.prefix}`,colors:{timestamp:"red",prefix:"red"}})}only(e){e()}createEntry(e,t){return{timestamp:new Date,level:e,message:t}}logEntry(e){const{level:t,message:s,prefix:r,colors:n,positionals:o=[]}=e,i=this.createEntry(t,s),a={timestamp:C[n?.timestamp||"gray"],prefix:C[n?.prefix||"gray"]};this.getWriter(t)([a.timestamp(this.formatTimestamp(i.timestamp))].concat(null!=r?a.prefix(r):[]).concat(V(s)).join(" "),...o.map(V))}formatTimestamp(e){return`${e.toLocaleTimeString("en-GB")}:${e.getMilliseconds()}`}getWriter(e){switch(e){case"debug":case"success":case"info":return $;case"warning":return B;case"error":return F}}},_=class{startTime;endTime;deltaTime;constructor(){this.startTime=performance.now()}measure(){this.endTime=performance.now();const e=this.endTime-this.startTime;this.deltaTime=e.toFixed(2)}},U=()=>{};function $(e,...t){D?f.stdout.write(v(e,...t)+"\n"):console.log(e,...t)}function B(e,...t){D?f.stderr.write(v(e,...t)+"\n"):console.warn(e,...t)}function F(e,...t){D?f.stderr.write(v(e,...t)+"\n"):console.error(e,...t)}function G(e){return D?f.env[e]:globalThis[e]?.toString()}function X(e,t){return void 0!==e&&e!==t}function V(e){return void 0===e?"undefined":null===e?"null":"string"==typeof e?e:"object"==typeof e?JSON.stringify(e):e.toString()}var K=class extends Error{constructor(e,t,s){super(`Possible EventEmitter memory leak detected. ${s} ${t.toString()} listeners added. Use emitter.setMaxListeners() to increase limit`),this.emitter=e,this.type=t,this.count=s,this.name="MaxListenersExceededWarning"}},J=class{static listenerCount(e,t){return e.listenerCount(t)}constructor(){this.events=new Map,this.maxListeners=J.defaultMaxListeners,this.hasWarnedAboutPotentialMemoryLeak=!1}_emitInternalEvent(e,t,s){this.emit(e,t,s)}_getListeners(e){return Array.prototype.concat.apply([],this.events.get(e))||[]}_removeListener(e,t){const s=e.indexOf(t);return s>-1&&e.splice(s,1),[]}_wrapOnceListener(e,t){const s=(...r)=>(this.removeListener(e,s),t.apply(this,r));return Object.defineProperty(s,"name",{value:t.name}),s}setMaxListeners(e){return this.maxListeners=e,this}getMaxListeners(){return this.maxListeners}eventNames(){return Array.from(this.events.keys())}emit(e,...t){const s=this._getListeners(e);return s.forEach((e=>{e.apply(this,t)})),s.length>0}addListener(e,t){this._emitInternalEvent("newListener",e,t);const s=this._getListeners(e).concat(t);if(this.events.set(e,s),this.maxListeners>0&&this.listenerCount(e)>this.maxListeners&&!this.hasWarnedAboutPotentialMemoryLeak){this.hasWarnedAboutPotentialMemoryLeak=!0;const t=new K(this,e,this.listenerCount(e));console.warn(t)}return this}on(e,t){return this.addListener(e,t)}once(e,t){return this.addListener(e,this._wrapOnceListener(e,t))}prependListener(e,t){const s=this._getListeners(e);if(s.length>0){const r=[t].concat(s);this.events.set(e,r)}else this.events.set(e,s.concat(t));return this}prependOnceListener(e,t){return this.prependListener(e,this._wrapOnceListener(e,t))}removeListener(e,t){const s=this._getListeners(e);return s.length>0&&(this._removeListener(s,t),this.events.set(e,s),this._emitInternalEvent("removeListener",e,t)),this}off(e,t){return this.removeListener(e,t)}removeAllListeners(e){return e?this.events.delete(e):this.events.clear(),this}listeners(e){return Array.from(this._getListeners(e))}listenerCount(e){return this._getListeners(e).length}rawListeners(e){return this.listeners(e)}},Q=J;Q.defaultMaxListeners=10;function Y(e){return globalThis[e]||void 0}var z=class{constructor(e){this.symbol=e,this.readyState="INACTIVE",this.emitter=new Q,this.subscriptions=[],this.logger=new N(e.description),this.emitter.setMaxListeners(0),this.logger.info("constructing the interceptor...")}checkEnvironment(){return!0}apply(){const e=this.logger.extend("apply");if(e.info("applying the interceptor..."),"APPLIED"===this.readyState)return void e.info("intercepted already applied!");if(!this.checkEnvironment())return void e.info("the interceptor cannot be applied in this environment!");this.readyState="APPLYING";const t=this.getInstance();if(t)return e.info("found a running instance, reusing..."),this.on=(s,r)=>(e.info('proxying the "%s" listener',s),t.emitter.addListener(s,r),this.subscriptions.push((()=>{t.emitter.removeListener(s,r),e.info('removed proxied "%s" listener!',s)})),this),void(this.readyState="APPLIED");e.info("no running instance found, setting up a new instance..."),this.setup(),this.setInstance(),this.readyState="APPLIED"}setup(){}on(e,t){const s=this.logger.extend("on");return"DISPOSING"===this.readyState||"DISPOSED"===this.readyState?(s.info("cannot listen to events, already disposed!"),this):(s.info('adding "%s" event listener:',e,t),this.emitter.on(e,t),this)}once(e,t){return this.emitter.once(e,t),this}off(e,t){return this.emitter.off(e,t),this}removeAllListeners(e){return this.emitter.removeAllListeners(e),this}dispose(){const e=this.logger.extend("dispose");if("DISPOSED"!==this.readyState)if(e.info("disposing the interceptor..."),this.readyState="DISPOSING",this.getInstance()){if(this.clearInstance(),e.info("global symbol deleted:",Y(this.symbol)),this.subscriptions.length>0){e.info("disposing of %d subscriptions...",this.subscriptions.length);for(const e of this.subscriptions)e();this.subscriptions=[],e.info("disposed of all subscriptions!",this.subscriptions.length)}this.emitter.removeAllListeners(),e.info("destroyed the listener!"),this.readyState="DISPOSED"}else e.info("no interceptors running, skipping dispose...");else e.info("cannot dispose, already disposed!")}getInstance(){var e;const t=Y(this.symbol);return this.logger.info("retrieved global instance:",null==(e=null==t?void 0:t.constructor)?void 0:e.name),t}setInstance(){var e,t;e=this.symbol,t=this,globalThis[e]=t,this.logger.info("set global instance!",this.symbol.description)}clearInstance(){var e;e=this.symbol,delete globalThis[e],this.logger.info("cleared global instance!",this.symbol.description)}};function Z(){return Math.random().toString(16).slice(2)}var ee=class extends z{constructor(e){ee.symbol=Symbol(e.name),super(ee.symbol),this.interceptors=e.interceptors}setup(){const e=this.logger.extend("setup");e.info("applying all %d interceptors...",this.interceptors.length);for(const t of this.interceptors)e.info('applying "%s" interceptor...',t.constructor.name),t.apply(),e.info("adding interceptor dispose subscription"),this.subscriptions.push((()=>t.dispose()))}on(e,t){for(const s of this.interceptors)s.on(e,t);return this}once(e,t){for(const s of this.interceptors)s.once(e,t);return this}off(e,t){for(const s of this.interceptors)s.off(e,t);return this}removeAllListeners(e){for(const t of this.interceptors)t.removeAllListeners(e);return this}};var te=e=>function(t,s){const n=(async()=>{e.events.removeAllListeners(),e.workerChannel.on("REQUEST",x(e,t)),e.workerChannel.on("RESPONSE",function(e){return(t,s)=>{const{payload:r}=s,{requestId:n}=r,o=e.requests.get(n);if(e.requests.delete(n),r.type?.includes("opaque"))return;const i=0===r.status?Response.error():new Response(P(r.status)?null:r.body,r);i.url||Object.defineProperty(i,"url",{value:o.url,enumerable:!0,writable:!1}),e.emitter.emit(r.isMockedResponse?"response:mocked":"response:bypass",{response:i,request:o,requestId:r.requestId})}}(e));const n=await R(t.serviceWorker.url,t.serviceWorker.options,t.findWorker),[o,i]=n;if(!o){const e=s?.findWorker?r.e.formatMessage('Failed to locate the Service Worker registration using a custom "findWorker" predicate.\n\nPlease ensure that the custom predicate properly locates the Service Worker registration at "%s".\nMore details: https://mswjs.io/docs/api/setup-worker/start#findworker\n',t.serviceWorker.url):r.e.formatMessage('Failed to locate the Service Worker registration.\n\nThis most likely means that the worker script URL "%s" cannot resolve against the actual public hostname (%s). This may happen if your application runs behind a proxy, or has a dynamic hostname.\n\nPlease consider using a custom "serviceWorker.url" option to point to the actual worker script location, or a custom "findWorker" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start',t.serviceWorker.url,location.host);throw new Error(e)}return e.worker=o,e.registration=i,e.events.addListener(window,"beforeunload",(()=>{"redundant"!==o.state&&e.workerChannel.send("CLIENT_CLOSED"),window.clearInterval(e.keepAliveInterval)})),await async function(e){e.workerChannel.send("INTEGRITY_CHECK_REQUEST");const{payload:t}=await e.events.once("INTEGRITY_CHECK_RESPONSE");"26357c79639bfa20d64c0efca2a87423"!==t.checksum&&r.e.warn(`The currently registered Service Worker has been generated by a different version of MSW (${t.packageVersion}) and may not be fully compatible with the installed version.\n\nIt's recommended you update your worker script by running this command:\n\n  \u2022 npx msw init <PUBLIC_DIR>\n\nYou can also automate this process and make the worker script update automatically upon the library installations. Read more: https://mswjs.io/docs/cli/init.`)}(e).catch((e=>{r.e.error("Error while checking the worker script integrity. Please report this on GitHub (https://github.com/mswjs/msw/issues), including the original error below."),console.error(e)})),e.keepAliveInterval=window.setInterval((()=>e.workerChannel.send("KEEPALIVE_REQUEST")),5e3),function(e,t){t?.quiet||location.href.startsWith(e.scope)||r.e.warn(`Cannot intercept requests on this page because it's outside of the worker's scope ("${e.scope}"). If you wish to mock API requests on this page, you must resolve this scope issue.\n\n- (Recommended) Register the worker at the root level ("/") of your application.\n- Set the "Service-Worker-Allowed" response header to allow out-of-scope workers.`)}(i,e.startOptions),i})().then((async s=>{const n=s.installing||s.waiting;return n&&await new Promise((e=>{n.addEventListener("statechange",(()=>{if("activated"===n.state)return e()}))})),await async function(e,t){e.workerChannel.send("MOCK_ACTIVATE"),await e.events.once("MOCKING_ENABLED"),e.isMockingEnabled?r.e.warn('Found a redundant "worker.start()" call. Note that starting the worker while mocking is already enabled will have no effect. Consider removing this "worker.start()" call.'):(e.isMockingEnabled=!0,E({quiet:t.quiet,workerScope:e.registration?.scope,workerUrl:e.worker?.scriptURL}))}(e,t).catch((e=>{throw new Error(`Failed to enable mocking: ${e?.message}`)})),s}));return n};function se(e={}){e.quiet||console.log(`%c${r.e.formatMessage("Mocking disabled.")}`,"color:orangered;font-weight:bold;")}var re={serviceWorker:{url:"/mockServiceWorker.js",options:null},quiet:!1,waitUntilReady:!0,onUnhandledRequest:"warn",findWorker:(e,t)=>e===t};var ne=class extends Promise{#e;resolve;reject;constructor(e=null){const t=function(){const e=(t,s)=>{e.state="pending",e.resolve=s=>{if("pending"===e.state)return e.result=s,t(s instanceof Promise?s:Promise.resolve(s).then((t=>(e.state="fulfilled",t))))},e.reject=t=>{if("pending"===e.state)return queueMicrotask((()=>{e.state="rejected"})),s(e.rejectionReason=t)}};return e}();super(((s,r)=>{t(s,r),e?.(t.resolve,t.reject)})),this.#e=t,this.resolve=this.#e.resolve,this.reject=this.#e.reject}get state(){return this.#e.state}get rejectionReason(){return this.#e.rejectionReason}then(e,t){return this.#t(super.then(e,t))}catch(e){return this.#t(super.catch(e))}finally(e){return this.#t(super.finally(e))}#t(e){return Object.defineProperties(e,{resolve:{configurable:!0,value:this.resolve},reject:{configurable:!0,value:this.reject}})}};function oe(e){const t=new class{constructor(e){this.request=e,this.responsePromise=new ne}respondWith(e){w("pending"===this.responsePromise.state,'Failed to respond to "%s %s" request: the "request" event has already been responded to.',this.request.method,this.request.url),this.responsePromise.resolve(e)}}(e);return Reflect.set(e,"respondWith",t.respondWith.bind(t)),{interactiveRequest:e,requestController:t}}async function ie(e,t,...s){const r=e.listeners(t);if(0!==r.length)for(const n of r)await n.apply(e,s)}var ae=class extends z{constructor(){super(ae.symbol)}checkEnvironment(){return"undefined"!=typeof globalThis&&void 0!==globalThis.fetch}async setup(){const e=globalThis.fetch;w(!e[I],'Failed to patch the "fetch" module: already patched.'),globalThis.fetch=async(t,s)=>{var r;const n=Z(),o="string"!=typeof t||"undefined"==typeof location||function(e){try{return new URL(e),!0}catch(t){return!1}}(t)?t:new URL(t,location.origin),i=new Request(o,s);this.logger.info("[%s] %s",i.method,i.url);const{interactiveRequest:a,requestController:l}=oe(i);this.logger.info('emitting the "request" event for %d listener(s)...',this.emitter.listenerCount("request")),this.emitter.once("request",(({requestId:e})=>{e===n&&"pending"===l.responsePromise.state&&l.responsePromise.resolve(void 0)})),this.logger.info("awaiting for the mocked response...");const c=a.signal,u=new ne;c&&c.addEventListener("abort",(()=>{u.reject(c.reason)}),{once:!0});const h=await q((async()=>{const e=ie(this.emitter,"request",{request:a,requestId:n});await Promise.race([u,e,l.responsePromise]),this.logger.info("all request listeners have been resolved!");const t=await l.responsePromise;return this.logger.info("event.respondWith called with:",t),t}));if("rejected"===u.state)return Promise.reject(u.rejectionReason);if(h.error)return Promise.reject(ce(h.error));const d=h.data;if(d&&!(null==(r=i.signal)?void 0:r.aborted)){if(this.logger.info("received mocked response:",d),function(e,t){try{return e[t],!0}catch(s){return!1}}(d,"type")&&"error"===d.type)return this.logger.info("received a network error response, rejecting the request promise..."),Promise.reject(ce(d));const e=d.clone();return this.emitter.emit("response",{response:e,isMockedResponse:!0,request:a,requestId:n}),Object.defineProperty(d,"url",{writable:!1,enumerable:!0,configurable:!1,value:i.url}),d}return this.logger.info("no mocked response received!"),e(i).then((e=>{const t=e.clone();return this.logger.info("original fetch performed",t),this.emitter.emit("response",{response:t,isMockedResponse:!1,request:a,requestId:n}),e}))},Object.defineProperty(globalThis.fetch,I,{enumerable:!0,configurable:!0,value:!0}),this.subscriptions.push((()=>{Object.defineProperty(globalThis.fetch,I,{value:void 0}),globalThis.fetch=e,this.logger.info('restored native "globalThis.fetch"!',globalThis.fetch.name)}))}},le=ae;function ce(e){return Object.assign(new TypeError("Failed to fetch"),{cause:e})}le.symbol=Symbol("fetch");var ue=class{constructor(e,t){this.AT_TARGET=0,this.BUBBLING_PHASE=0,this.CAPTURING_PHASE=0,this.NONE=0,this.type="",this.srcElement=null,this.currentTarget=null,this.eventPhase=0,this.isTrusted=!0,this.composed=!1,this.cancelable=!0,this.defaultPrevented=!1,this.bubbles=!0,this.lengthComputable=!0,this.loaded=0,this.total=0,this.cancelBubble=!1,this.returnValue=!0,this.type=e,this.target=(null==t?void 0:t.target)||null,this.currentTarget=(null==t?void 0:t.currentTarget)||null,this.timeStamp=Date.now()}composedPath(){return[]}initEvent(e,t,s){this.type=e,this.bubbles=!!t,this.cancelable=!!s}preventDefault(){this.defaultPrevented=!0}stopPropagation(){}stopImmediatePropagation(){}},he=class extends ue{constructor(e,t){super(e),this.lengthComputable=(null==t?void 0:t.lengthComputable)||!1,this.composed=(null==t?void 0:t.composed)||!1,this.loaded=(null==t?void 0:t.loaded)||0,this.total=(null==t?void 0:t.total)||0}},de="undefined"!=typeof ProgressEvent;function pe(e,t){if(!(t in e))return null;if(Object.prototype.hasOwnProperty.call(e,t))return e;const s=Reflect.getPrototypeOf(e);return s?pe(s,t):null}function ge(e,t){const s=new Proxy(e,function(e){const{constructorCall:t,methodCall:s,getProperty:r,setProperty:n}=e,o={};void 0!==t&&(o.construct=function(e,s,r){const n=Reflect.construct.bind(null,e,s,r);return t.call(r,s,n)});return o.set=function(e,t,s){const r=()=>{const r=pe(e,t)||e,n=Reflect.getOwnPropertyDescriptor(r,t);return void 0!==(null==n?void 0:n.set)?(n.set.apply(e,[s]),!0):Reflect.defineProperty(r,t,{writable:!0,enumerable:!0,configurable:!0,value:s})};return void 0!==n?n.call(e,[t,s],r):r()},o.get=function(e,t,n){const o=()=>e[t],i=void 0!==r?r.call(e,[t,n],o):o();return"function"==typeof i?(...r)=>{const n=i.bind(e,...r);return void 0!==s?s.call(e,[t,r],n):n()}:i},o}(t));return s}function fe(e){const t=new Headers,s=e.split(/[\r\n]+/);for(const r of s){if(""===r.trim())continue;const[e,...s]=r.split(": "),n=s.join(": ");t.append(e,n)}return t}var me=Symbol("isMockedResponse"),ve=b();function ye(e){return"undefined"==typeof location?new URL(e):new URL(e.toString(),location.href)}function we(e,t,s){Reflect.defineProperty(e,t,{writable:!0,enumerable:!0,value:s})}function be({emitter:e,logger:t}){return new Proxy(globalThis.XMLHttpRequest,{construct(s,r,n){t.info("constructed new XMLHttpRequest");const o=Reflect.construct(s,r,n),i=Object.getOwnPropertyDescriptors(s.prototype);for(const e in i)Reflect.defineProperty(o,e,i[e]);const a=new class{constructor(e,t){this.initialRequest=e,this.logger=t,this.method="GET",this.url=null,this.events=new Map,this.requestId=Z(),this.requestHeaders=new Headers,this.responseBuffer=new Uint8Array,this.request=ge(e,{setProperty:([e,t],s)=>{if("ontimeout"===e){const r=e.slice(2);return this.request.addEventListener(r,t),s()}return s()},methodCall:([e,t],s)=>{var r,n;switch(e){case"open":{const[e,r]=t;return void 0===r?(this.method="GET",this.url=ye(e)):(this.method=e,this.url=ye(r)),this.logger=this.logger.extend(`${this.method} ${this.url.href}`),this.logger.info("open",this.method,this.url.href),s()}case"addEventListener":{const[e,r]=t;return this.registerEvent(e,r),this.logger.info("addEventListener",e,r),s()}case"setRequestHeader":{const[e,r]=t;return this.requestHeaders.set(e,r),this.logger.info("setRequestHeader",e,r),s()}case"send":{const[e]=t;null!=e&&(this.requestBody="string"==typeof e?(n=e,T.encode(n)):e),this.request.addEventListener("load",(()=>{if(void 0!==this.onResponse){const e=function(e,t){const s=P(e.status)?null:t;return new Response(s,{status:e.status,statusText:e.statusText,headers:fe(e.getAllResponseHeaders())})}(this.request,this.request.response);this.onResponse.call(this,{response:e,isMockedResponse:me in this.request,request:o,requestId:this.requestId})}}));const o=this.toFetchApiRequest();((null==(r=this.onRequest)?void 0:r.call(this,{request:o,requestId:this.requestId}))||Promise.resolve()).finally((()=>{if(this.request.readyState<this.request.LOADING)return this.logger.info("request callback settled but request has not been handled (readystate %d), performing as-is...",this.request.readyState),ve&&this.request.setRequestHeader("x-interceptors-internal-request-id",this.requestId),s()}));break}default:return s()}}})}registerEvent(e,t){const s=(this.events.get(e)||[]).concat(t);this.events.set(e,s),this.logger.info('registered event "%s"',e,t)}respondWith(e){this.logger.info("responding with a mocked response: %d %s",e.status,e.statusText),we(this.request,me,!0),we(this.request,"status",e.status),we(this.request,"statusText",e.statusText),we(this.request,"responseURL",this.url.href),this.request.getResponseHeader=new Proxy(this.request.getResponseHeader,{apply:(t,s,r)=>{if(this.logger.info("getResponseHeader",r[0]),this.request.readyState<this.request.HEADERS_RECEIVED)return this.logger.info("headers not received yet, returning null"),null;const n=e.headers.get(r[0]);return this.logger.info('resolved response header "%s" to',r[0],n),n}}),this.request.getAllResponseHeaders=new Proxy(this.request.getAllResponseHeaders,{apply:()=>{if(this.logger.info("getAllResponseHeaders"),this.request.readyState<this.request.HEADERS_RECEIVED)return this.logger.info("headers not received yet, returning empty string"),"";const t=Array.from(e.headers.entries()).map((([e,t])=>`${e}: ${t}`)).join("\r\n");return this.logger.info("resolved all response headers to",t),t}}),Object.defineProperties(this.request,{response:{enumerable:!0,configurable:!1,get:()=>this.response},responseText:{enumerable:!0,configurable:!1,get:()=>this.responseText},responseXML:{enumerable:!0,configurable:!1,get:()=>this.responseXML}});const t=e.headers.has("Content-Length")?Number(e.headers.get("Content-Length")):void 0;this.logger.info("calculated response body length",t),this.trigger("loadstart",{loaded:0,total:t}),this.setReadyState(this.request.HEADERS_RECEIVED),this.setReadyState(this.request.LOADING);const s=()=>{this.logger.info("finalizing the mocked response..."),this.setReadyState(this.request.DONE),this.trigger("load",{loaded:this.responseBuffer.byteLength,total:t}),this.trigger("loadend",{loaded:this.responseBuffer.byteLength,total:t})};if(e.body){this.logger.info("mocked response has body, streaming...");const r=e.body.getReader(),n=async()=>{const{value:e,done:o}=await r.read();if(o)return this.logger.info("response body stream done!"),void s();e&&(this.logger.info("read response body chunk:",e),this.responseBuffer=function(e,t){const s=new Uint8Array(e.byteLength+t.byteLength);return s.set(e,0),s.set(t,e.byteLength),s}(this.responseBuffer,e),this.trigger("progress",{loaded:this.responseBuffer.byteLength,total:t})),n()};n()}else s()}responseBufferToText(){return e=this.responseBuffer,new TextDecoder(t).decode(e);var e,t}get response(){if(this.logger.info("getResponse (responseType: %s)",this.request.responseType),this.request.readyState!==this.request.DONE)return null;switch(this.request.responseType){case"json":{const e=function(e){try{return JSON.parse(e)}catch(t){return null}}(this.responseBufferToText());return this.logger.info("resolved response JSON",e),e}case"arraybuffer":{const t=(e=this.responseBuffer).buffer.slice(e.byteOffset,e.byteOffset+e.byteLength);return this.logger.info("resolved response ArrayBuffer",t),t}case"blob":{const e=this.request.getResponseHeader("Content-Type")||"text/plain",t=new Blob([this.responseBufferToText()],{type:e});return this.logger.info("resolved response Blob (mime type: %s)",t,e),t}default:{const e=this.responseBufferToText();return this.logger.info('resolving "%s" response type as text',this.request.responseType,e),e}}var e}get responseText(){if(w(""===this.request.responseType||"text"===this.request.responseType,"InvalidStateError: The object is in invalid state."),this.request.readyState!==this.request.LOADING&&this.request.readyState!==this.request.DONE)return"";const e=this.responseBufferToText();return this.logger.info('getResponseText: "%s"',e),e}get responseXML(){if(w(""===this.request.responseType||"document"===this.request.responseType,"InvalidStateError: The object is in invalid state."),this.request.readyState!==this.request.DONE)return null;const e=this.request.getResponseHeader("Content-Type")||"";return"undefined"==typeof DOMParser?(console.warn("Cannot retrieve XMLHttpRequest response body as XML: DOMParser is not defined. You are likely using an environment that is not browser or does not polyfill browser globals correctly."),null):(t=e,["application/xhtml+xml","application/xml","image/svg+xml","text/html","text/xml"].some((e=>t.startsWith(e)))?(new DOMParser).parseFromString(this.responseBufferToText(),e):null);var t}errorWith(e){this.logger.info("responding with an error"),this.setReadyState(this.request.DONE),this.trigger("error"),this.trigger("loadend")}setReadyState(e){this.logger.info("setReadyState: %d -> %d",this.request.readyState,e),this.request.readyState!==e?(we(this.request,"readyState",e),this.logger.info("set readyState to: %d",e),e!==this.request.UNSENT&&(this.logger.info('triggerring "readystatechange" event...'),this.trigger("readystatechange"))):this.logger.info("ready state identical, skipping transition...")}trigger(e,t){const s=this.request[`on${e}`],r=function(e,t,s){const r=de?ProgressEvent:he;return["error","progress","loadstart","loadend","load","timeout","abort"].includes(t)?new r(t,{lengthComputable:!0,loaded:(null==s?void 0:s.loaded)||0,total:(null==s?void 0:s.total)||0}):new ue(t,{target:e,currentTarget:e})}(this.request,e,t);this.logger.info('trigger "%s"',e,t||""),"function"==typeof s&&(this.logger.info('found a direct "%s" callback, calling...',e),s.call(this.request,r));for(const[n,o]of this.events)n===e&&(this.logger.info('found %d listener(s) for "%s" event, calling...',o.length,e),o.forEach((e=>e.call(this.request,r))))}toFetchApiRequest(){this.logger.info("converting request to a Fetch API Request...");const e=new Request(this.url.href,{method:this.method,headers:this.requestHeaders,credentials:this.request.withCredentials?"include":"same-origin",body:["GET","HEAD"].includes(this.method)?null:this.requestBody}),t=ge(e.headers,{methodCall:([t,s],r)=>{switch(t){case"append":case"set":{const[e,t]=s;this.request.setRequestHeader(e,t);break}case"delete":{const[t]=s;console.warn(`XMLHttpRequest: Cannot remove a "${t}" header from the Fetch API representation of the "${e.method} ${e.url}" request. XMLHttpRequest headers cannot be removed.`);break}}return r()}});return we(e,"headers",t),this.logger.info("converted request to a Fetch API Request!",e),e}}(o,t);return a.onRequest=async function({request:t,requestId:s}){const{interactiveRequest:r,requestController:n}=oe(t);this.logger.info("awaiting mocked response..."),e.once("request",(({requestId:e})=>{e===s&&"pending"===n.responsePromise.state&&n.respondWith(void 0)}));const o=await q((async()=>{this.logger.info('emitting the "request" event for %s listener(s)...',e.listenerCount("request")),await ie(e,"request",{request:r,requestId:s}),this.logger.info('all "request" listeners settled!');const t=await n.responsePromise;return this.logger.info("event.respondWith called with:",t),t}));if(o.error)return this.logger.info("request listener threw an exception, aborting request...",o.error),void a.errorWith(o.error);const i=o.data;if(void 0!==i)return this.logger.info("received mocked response: %d %s",i.status,i.statusText),"error"===i.type?(this.logger.info("received a network error response, rejecting the request promise..."),void a.errorWith(new TypeError("Network error"))):a.respondWith(i);this.logger.info("no mocked response received, performing request as-is...")},a.onResponse=async function({response:t,isMockedResponse:s,request:r,requestId:n}){this.logger.info('emitting the "response" event for %s listener(s)...',e.listenerCount("response")),e.emit("response",{response:t,isMockedResponse:s,request:r,requestId:n})},a.request}})}var qe=class extends z{constructor(){super(qe.interceptorSymbol)}checkEnvironment(){return void 0!==globalThis.XMLHttpRequest}setup(){const e=this.logger.extend("setup");e.info('patching "XMLHttpRequest" module...');const t=globalThis.XMLHttpRequest;w(!t[I],'Failed to patch the "XMLHttpRequest" module: already patched.'),globalThis.XMLHttpRequest=be({emitter:this.emitter,logger:this.logger}),e.info('native "XMLHttpRequest" module patched!',globalThis.XMLHttpRequest.name),Object.defineProperty(globalThis.XMLHttpRequest,I,{enumerable:!0,configurable:!0,value:!0}),this.subscriptions.push((()=>{Object.defineProperty(globalThis.XMLHttpRequest,I,{value:void 0}),globalThis.XMLHttpRequest=t,e.info('native "XMLHttpRequest" module restored!',globalThis.XMLHttpRequest.name)}))}},ke=qe;function Re(e){return async function(t){e.fallbackInterceptor=function(e,t){const s=new ee({name:"fallback",interceptors:[new le,new ke]});return s.on("request",(async({request:s,requestId:r})=>{const n=s.clone(),o=await a(s,r,e.getRequestHandlers(),t,e.emitter,{onMockedResponse(s,{handler:r,parsedResult:o}){t.quiet||e.emitter.once("response:mocked",(({response:e})=>{r.log({request:n,response:e,parsedResult:o})}))}});o&&s.respondWith(o)})),s.on("response",(({response:t,isMockedResponse:s,request:r,requestId:n})=>{e.emitter.emit(s?"response:mocked":"response:bypass",{response:t,request:r,requestId:n})})),s.apply(),s}(e,t),E({message:"Mocking enabled (fallback mode).",quiet:t.quiet})}}function Ee(){try{const e=new ReadableStream({start:e=>e.close()});return(new MessageChannel).port1.postMessage(e,[e]),!0}catch(e){return!1}}ke.interceptorSymbol=Symbol("xhr");var Le=class extends d{context;startHandler=null;stopHandler=null;listeners;constructor(...e){super(...e),w(!b(),r.e.formatMessage("Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead.")),this.listeners=[],this.context=this.createWorkerContext()}createWorkerContext(){const e={isMockingEnabled:!1,startOptions:null,worker:null,getRequestHandlers:()=>this.handlersController.currentHandlers(),registration:null,requests:new Map,emitter:this.emitter,workerChannel:{on:(e,t)=>{this.context.events.addListener(navigator.serviceWorker,"message",(s=>{if(s.source!==this.context.worker)return;const r=s.data;r&&r.type===e&&t(s,r)}))},send:e=>{this.context.worker?.postMessage(e)}},events:{addListener:(e,t,s)=>(e.addEventListener(t,s),this.listeners.push({eventType:t,target:e,callback:s}),()=>{e.removeEventListener(t,s)}),removeAllListeners:()=>{for(const{target:e,eventType:t,callback:s}of this.listeners)e.removeEventListener(t,s);this.listeners=[]},once:e=>{const t=[];return new Promise(((s,r)=>{t.push(this.context.events.addListener(navigator.serviceWorker,"message",(t=>{try{const r=t.data;r.type===e&&s(r)}catch(n){r(n)}})),this.context.events.addListener(navigator.serviceWorker,"messageerror",r))})).finally((()=>{t.forEach((e=>e()))}))}},supports:{serviceWorkerApi:!("serviceWorker"in navigator)||"file:"===location.protocol,readableStreamTransfer:Ee()}};return this.startHandler=e.supports.serviceWorkerApi?Re(e):te(e),this.stopHandler=e.supports.serviceWorkerApi?function(e){return function(){e.fallbackInterceptor?.dispose(),se({quiet:e.startOptions?.quiet})}}(e):(e=>function(){e.isMockingEnabled?(e.workerChannel.send("MOCK_DEACTIVATE"),e.isMockingEnabled=!1,window.clearInterval(e.keepAliveInterval),se({quiet:e.startOptions?.quiet})):r.e.warn('Found a redundant "worker.stop()" call. Note that stopping the worker while mocking already stopped has no effect. Consider removing this "worker.stop()" call.')})(e),e}async start(e={}){return!0===e.waitUntilReady&&r.e.warn('The "waitUntilReady" option has been deprecated. Please remove it from this "worker.start()" call. Follow the recommended Browser integration (https://mswjs.io/docs/integrations/browser) to eliminate any race conditions between the Service Worker registration and any requests made by your application on initial render.'),this.context.startOptions=g(re,e),await this.startHandler(this.context.startOptions,e)}stop(){super.dispose(),this.context.events.removeAllListeners(),this.context.emitter.removeAllListeners(),this.stopHandler()}};function xe(...e){return new Le(...e)}}}]);