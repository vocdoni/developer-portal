"use strict";(self.webpackChunkdemo=self.webpackChunkdemo||[]).push([[2872],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(67294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,o=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=c(n),h=s,m=d["".concat(l,".").concat(h)]||d[h]||u[h]||o;return n?a.createElement(m,r(r({ref:t},p),{},{components:n})):a.createElement(m,r({ref:t},p))}));function h(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var o=n.length,r=new Array(o);r[0]=d;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:s,r[1]=i;for(var c=2;c<o;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},67864:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var a=n(87462),s=(n(67294),n(3905));const o={},r="Complex Census",i={unversionedId:"sdk/integration-details/census-types/on-chain/complex-census",id:"sdk/integration-details/census-types/on-chain/complex-census",title:"Complex Census",description:"The census3 service makes it easy to create a census based off of the balance holders of a token taken to represent an organization. It is possible, however, to create a token-based census with more complex logic, incorporating balance information from multiple tokens at once.",source:"@site/docs/sdk/integration-details/census-types/on-chain/complex-census.md",sourceDirName:"sdk/integration-details/census-types/on-chain",slug:"/sdk/integration-details/census-types/on-chain/complex-census",permalink:"/sdk/integration-details/census-types/on-chain/complex-census",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"On-chain Token-Based Census",permalink:"/sdk/integration-details/census-types/on-chain/"},next:{title:"Vocdoni Tokens",permalink:"/sdk/integration-details/vocdoni-tokens"}},l={},c=[{value:"Strategies",id:"strategies",level:2},{value:"Predicates",id:"predicates",level:2},{value:"Creating a Census",id:"creating-a-census",level:2}],p={toc:c};function u(e){let{components:t,...n}=e;return(0,s.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"complex-census"},"Complex Census"),(0,s.kt)("p",null,"The census3 service makes it easy to create a census based off of the balance holders of a token taken to represent an organization. It is possible, however, to create a token-based census with more complex logic, incorporating balance information from multiple tokens at once."),(0,s.kt)("h2",{id:"strategies"},"Strategies"),(0,s.kt)("p",null,"The logic that defines inclusion in a token-based census is called a 'strategy.' For the basic token-holder use case, the strategy is defined solely by that token. ",(0,s.kt)("inlineCode",{parentName:"p"},"createTokenCensus")," chooses the default strategy for that token, so for a basic token-based census you don't need to worry about strategies at all."),(0,s.kt)("p",null,'More complex strategies exist, however, such as "holders of both ',(0,s.kt)("inlineCode",{parentName:"p"},"VOC1")," token AND ",(0,s.kt)("inlineCode",{parentName:"p"},"VOC2"),' token."'),(0,s.kt)("p",null,"Just like checking for supported tokens, you can see a list of the strategies supported by the census3 service:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const strategies = await census3Client.getStrategies();\nconsole.log(JSON.stringify(strategies, null, 4));\n")),(0,s.kt)("p",null,"This will print a long list of strategies. Some of them will be basic strategies for a single token:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'...\n  {\n        "ID": 72,\n        "alias": "Default strategy for token VOC3TEST",\n        "predicate": "VOC3TEST",\n        "uri": "ipfs://bafybeih7rmjsdzqjr6pyjv46jo4kjpl3qfv2yufpdxzmcw2j63z47u6czy",\n        "tokens": {\n            "VOC3TEST": {\n                "ID": "0x9286d95DB5a59306113028EF0BA85bF7068A199F",\n                "chainID": 11155111,\n                "minBalance": "1",\n                "chainAddress": "sep:0x9286d95DB5a59306113028EF0BA85bF7068A199F"\n            }\n        }\n    },\n...\n')),(0,s.kt)("p",null,"Some, on the other hand, will be more complex strategies involving multiple tokens:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'...\n  {\n        "ID": 103,\n        "alias": "gitcoin_onvote_1711040172449",\n        "predicate": "GPS AND:mul (GPS:Discord OR GPS:Github)",\n        "uri": "ipfs://bafybeidopynxc746oorzkh7yvhomcw56w72aaw3klqce4gkjcczc7ry3uu",\n        "tokens": {\n            "GPS": {\n                "ID": "0x000000000000000000000000000000000000006C",\n                "chainID": 1,\n                "minBalance": "16",\n                "chainAddress": "eth:0x000000000000000000000000000000000000006C"\n            },\n            "GPS:Discord": {\n                "ID": "0x000000000000000000000000000000000000006C",\n                "chainID": 1,\n                "minBalance": "1",\n                "chainAddress": "eth:0x000000000000000000000000000000000000006C",\n                "externalID": "Discord"\n            },\n            "GPS:Github": {\n                "ID": "0x000000000000000000000000000000000000006C",\n                "chainID": 1,\n                "minBalance": "1",\n                "chainAddress": "eth:0x000000000000000000000000000000000000006C",\n                "externalID": "Github"\n            }\n        }\n    },\n...\n')),(0,s.kt)("h2",{id:"predicates"},"Predicates"),(0,s.kt)("p",null,"As you can see, there are two main differences between the simple and complex strategies: the ",(0,s.kt)("inlineCode",{parentName:"p"},"predicate")," and the ",(0,s.kt)("inlineCode",{parentName:"p"},"tokens"),". "),(0,s.kt)("p",null,"Predicates are logical operators that define how strategies create a census. There are currently two logical operators (",(0,s.kt)("inlineCode",{parentName:"p"},"AND")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"OR"),"), each with two additional 'powerups' (",(0,s.kt)("inlineCode",{parentName:"p"},"sum")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"mul"),")."),(0,s.kt)("p",null,"The predicate syntax and available operators are documented in-depth at ",(0,s.kt)("a",{parentName:"p",href:"/protocol/census/on-chain/census3#creating-a-strategy"},"Creating a Strategy"),"."),(0,s.kt)("p",null,"You can also query the census3 service for a list of available operators:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const operators = await census3Client.getSupportedOperators();\nconsole.log(operators);\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"[\n  {\n    description: 'AND logical operator that returns the common token holders between symbols with fixed balance to 1',\n    tag: 'AND'\n  },\n  {\n    description: 'AND:sum logical operator that returns the common token holders between symbols with the sum of their balances on both tokens',\n    tag: 'AND:sum'\n  },\n  {\n    description: 'AND:mul logical operator that returns the common token holders between symbols with the multiplication of their balances on both tokens',\n    tag: 'AND:mul'\n  },\n  {\n    description: 'OR logical operator that returns the token holders of both symbols with fixed balance to 1',\n    tag: 'OR'\n  },\n  {\n    description: 'OR:sum logical operator that returns the token holders of both symbols with the sum of their balances on both tokens',\n    tag: 'OR:sum'\n  },\n  {\n    description: 'OR:mul logical operator that returns the token holders of both symbols with the multiplication of their balances on both tokens',\n    tag: 'OR:mul'\n  }\n]\n")),(0,s.kt)("p",null,"As seen in the strategy example above, you can combine operators to create complex predicates with many tokens: "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-json"},'"predicate": "GPS AND:mul (GPS:Discord OR GPS:Github)"\n')),(0,s.kt)("h2",{id:"creating-a-census"},"Creating a Census"),(0,s.kt)("p",null,"The first step in creating a complex census is to create the strategy itself. You can write a predicate with the operators defined above and use the predicate with ",(0,s.kt)("a",{parentName:"p",href:"/sdk/reference/classes/vocdonicensus3client#createstrategy"},(0,s.kt)("inlineCode",{parentName:"a"},"createStrategy()")),". The only requirement is that you include a list of the necessary tokens used by this predicate, including the token ",(0,s.kt)("inlineCode",{parentName:"p"},"ID")," (address), ",(0,s.kt)("inlineCode",{parentName:"p"},"chainID"),", and optionally the ",(0,s.kt)("inlineCode",{parentName:"p"},"minBalance")," (the minimum necessary balance to include a token-holder in a census)."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const strategyID = await census3Client.createStrategy('voc_test_strategy', 'VOC3TEST AND VOC3TEST2', {\n  VOC3TEST: {\n    ID: '0x9286d95DB5a59306113028EF0BA85bF7068A199F',\n    chainID: 11155111,\n    minBalance: '1',\n  },\n  VOC3TEST2: {\n    ID: '0x61353Bc49B062EEe99F4768225f4e4f0df5DB1b9',\n    chainID: 11155111,\n    minBalance: '1',\n  },\n});\n")),(0,s.kt)("p",null,"This API call, if successful, returns the ID of the newly-created strategy. You can also use ",(0,s.kt)("inlineCode",{parentName:"p"},"getStrategies()")," again to make sure the strategy is supported. This ID is needed to create the census based off of the strategy:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const census = await census3Client.createStrategyCensus(strategyID);\n")),(0,s.kt)("p",null,"This returns a census can be used to create an election just like any other. In this case, the census would represent all token-holders of the ",(0,s.kt)("inlineCode",{parentName:"p"},"VOC3TEST")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"VOC3TEST3")," tokens, all with a weight of 1. The selected strategy is displayed in the ",(0,s.kt)("inlineCode",{parentName:"p"},"meta")," field of a token-based election."))}u.isMDXComponent=!0}}]);